import { type NextRequest, NextResponse } from "next/server"

// Business hours validation - Orari negozio: 9:00-12:00 e 14:00-18:00
function isBusinessHours(time: string): boolean {
  const [hourStr, minuteStr] = time.split(":")
  const hour = Number.parseInt(hourStr)
  const minute = Number.parseInt(minuteStr)
  const totalMinutes = hour * 60 + minute

  // Orari mattina: 9:00 - 12:00
  const morningStart = 9 * 60 // 9:00
  const morningEnd = 12 * 60 // 12:00

  // Orari pomeriggio: 14:00 - 18:00
  const afternoonStart = 14 * 60 // 14:00
  const afternoonEnd = 18 * 60 // 18:00

  // Check se √® negli orari di apertura
  const isMorning = totalMinutes >= morningStart && totalMinutes < morningEnd
  const isAfternoon = totalMinutes >= afternoonStart && totalMinutes < afternoonEnd

  return isMorning || isAfternoon
}

// Generate available time slots (every 30 minutes)
function getAvailableTimeSlots(): string[] {
  const slots: string[] = []

  // Mattina: 9:00 - 12:00 (ogni 30 minuti)
  for (let hour = 9; hour < 12; hour++) {
    slots.push(`${hour.toString().padStart(2, "0")}:00`)
    slots.push(`${hour.toString().padStart(2, "0")}:30`)
  }

  // Pomeriggio: 14:00 - 18:00 (ogni 30 minuti)
  for (let hour = 14; hour < 18; hour++) {
    slots.push(`${hour.toString().padStart(2, "0")}:00`)
    slots.push(`${hour.toString().padStart(2, "0")}:30`)
  }

  return slots
}

// Check availability in database
async function checkSlotAvailability(date: string, time: string): Promise<boolean> {
  try {
    console.log(`üîç Checking availability for ${date} at ${time}`)

    const response = await fetch(
      `${process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000"}/api/appointments/availability`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ date, time }),
      },
    )

    if (!response.ok) {
      console.error("‚ùå Error checking availability")
      return true // Default to available if check fails
    }

    const data = await response.json()
    return data.available
  } catch (error) {
    console.error("‚ùå Error checking slot availability:", error)
    return true // Default to available if check fails
  }
}

function getBusinessHoursMessage(language: string): string {
  const messages = {
    it: `üè™ **NEGOZIO CHIUSO**

‚è∞ **ORARI DI APERTURA:**

üåÖ **Mattina**: 09:00 - 12:00
üåÜ **Pomeriggio**: 14:00 - 18:00

‚ùå **Chiuso**: 12:00 - 14:00 (pausa pranzo)
‚ùå **Chiuso**: Prima delle 09:00 e dopo le 18:00

üìÖ **Appuntamenti ogni 30 minuti**
(es: 9:00, 9:30, 10:00, 10:30, etc.)

Per favore scegli un orario durante l'apertura del negozio.`,

    en: `üè™ **SHOP CLOSED**

‚è∞ **OPENING HOURS:**

üåÖ **Morning**: 09:00 - 12:00
üåÜ **Afternoon**: 14:00 - 18:00

‚ùå **Closed**: 12:00 - 14:00 (lunch break)
‚ùå **Closed**: Before 09:00 and after 18:00

üìÖ **Appointments every 30 minutes**
(e.g: 9:00, 9:30, 10:00, 10:30, etc.)

Please choose a time during shop opening hours.`,
  }

  return messages[language as keyof typeof messages] || messages.it
}

export async function POST(request: NextRequest) {
  try {
    const { step, message, bookingData = {}, language = "it" } = await request.json()

    console.log(`üìÖ Booking API - Step: ${step}, Language: ${language}`)

    const lang = language as "it" | "en"

    switch (step) {
      case "service_selection": {
        const lowerMessage = message.toLowerCase()
        let selectedService = ""

        // Parse service selection
        if (lowerMessage.includes("1") || lowerMessage.includes("automation") || lowerMessage.includes("automazione")) {
          selectedService = "AI Automation"
        } else if (lowerMessage.includes("2") || lowerMessage.includes("chatbot") || lowerMessage.includes("bot")) {
          selectedService = "Chatbot Intelligenti"
        } else if (lowerMessage.includes("3") || lowerMessage.includes("web") || lowerMessage.includes("sito")) {
          selectedService = "Web Development"
        } else if (lowerMessage.includes("4") || lowerMessage.includes("marketing")) {
          selectedService = "AI Marketing"
        }

        if (!selectedService) {
          const retryMessages = {
            it: `‚ùå **Servizio non riconosciuto**

Per favore scegli uno dei servizi disponibili:

1Ô∏è‚É£ **AI Automation**
2Ô∏è‚É£ **Chatbot Intelligenti** 
3Ô∏è‚É£ **Web Development**
4Ô∏è‚É£ **AI Marketing**

Scrivi il numero o il nome del servizio.`,

            en: `‚ùå **Service not recognized**

Please choose one of the available services:

1Ô∏è‚É£ **AI Automation**
2Ô∏è‚É£ **Intelligent Chatbots**
3Ô∏è‚É£ **Web Development** 
4Ô∏è‚É£ **AI Marketing**

Write the number or service name.`,
          }

          return NextResponse.json({
            success: true,
            message: retryMessages[lang],
            nextStep: "service_selection",
            bookingData,
          })
        }

        const confirmMessages = {
          it: `‚úÖ **Servizio selezionato: ${selectedService}**

üìÖ **SELEZIONE DATA**

Quando preferisci la consulenza?

**üìã Scrivi la data che preferisci:**
- **Oggi** (se disponibile)
- **Domani** 
- **Data specifica** (es: "15 settembre", "20/09/2024")
- **Giorno della settimana** (es: "gioved√¨ prossimo")

**Esempio:** "domani", "15 settembre", "gioved√¨"

**Quando vuoi prenotare?**`,

          en: `‚úÖ **Selected service: ${selectedService}**

üìÖ **DATE SELECTION**

When do you prefer the consultation?

**üìã Write your preferred date:**
- **Today** (if available)
- **Tomorrow**
- **Specific date** (e.g: "September 15", "20/09/2024")
- **Day of week** (e.g: "next Thursday")

**Example:** "tomorrow", "September 15", "Thursday"

**When do you want to book?**`,
        }

        return NextResponse.json({
          success: true,
          message: confirmMessages[lang],
          nextStep: "date_selection",
          bookingData: { ...bookingData, service: selectedService },
        })
      }

      case "date_selection": {
        // Parse date from message
        const lowerMessage = message.toLowerCase()
        let selectedDate = ""

        if (lowerMessage.includes("oggi") || lowerMessage.includes("today")) {
          selectedDate = new Date().toLocaleDateString("it-IT")
        } else if (lowerMessage.includes("domani") || lowerMessage.includes("tomorrow")) {
          const tomorrow = new Date()
          tomorrow.setDate(tomorrow.getDate() + 1)
          selectedDate = tomorrow.toLocaleDateString("it-IT")
        } else {
          // Default to tomorrow if can't parse
          const tomorrow = new Date()
          tomorrow.setDate(tomorrow.getDate() + 1)
          selectedDate = tomorrow.toLocaleDateString("it-IT")
        }

        // Get available time slots
        const timeSlots = getAvailableTimeSlots()

        const timeMessages = {
          it: `üìÖ **Data selezionata: ${selectedDate}**

üïê **SELEZIONE ORARIO**

‚è∞ **ORARI DISPONIBILI** (ogni 30 minuti):

**üåÖ MATTINA (9:00 - 12:00):**
${timeSlots
  .filter((time) => Number.parseInt(time.split(":")[0]) < 12)
  .map((time, index) => `${index + 1}Ô∏è‚É£ **${time}**`)
  .join("\n")}

**üåÜ POMERIGGIO (14:00 - 18:00):**
${timeSlots
  .filter((time) => Number.parseInt(time.split(":")[0]) >= 14)
  .map((time, index) => `${index + 7}Ô∏è‚É£ **${time}**`)
  .join("\n")}

**Quale orario preferisci?**
Scrivi il numero o l'orario esatto (es: "3" oppure "10:30")

üí° **Nota**: Controller√≤ la disponibilit√† nel database`,

          en: `üìÖ **Selected date: ${selectedDate}**

üïê **TIME SELECTION**

‚è∞ **AVAILABLE TIMES** (every 30 minutes):

**üåÖ MORNING (9:00 - 12:00):**
${timeSlots
  .filter((time) => Number.parseInt(time.split(":")[0]) < 12)
  .map((time, index) => `${index + 1}Ô∏è‚É£ **${time}**`)
  .join("\n")}

**üåÜ AFTERNOON (14:00 - 18:00):**
${timeSlots
  .filter((time) => Number.parseInt(time.split(":")[0]) >= 14)
  .map((time, index) => `${index + 7}Ô∏è‚É£ **${time}**`)
  .join("\n")}

**Which time do you prefer?**
Write the number or exact time (e.g: "3" or "10:30")

üí° **Note**: I'll check availability in the database`,
        }

        return NextResponse.json({
          success: true,
          message: timeMessages[lang],
          nextStep: "time_selection",
          bookingData: { ...bookingData, date: selectedDate },
        })
      }

      case "time_selection": {
        const lowerMessage = message.toLowerCase()
        const timeSlots = getAvailableTimeSlots()
        let selectedTime = ""

        // Parse time selection by number or direct time
        if (
          lowerMessage.includes("1") &&
          !lowerMessage.includes("10") &&
          !lowerMessage.includes("11") &&
          !lowerMessage.includes("12")
        ) {
          selectedTime = "09:00"
        } else if (lowerMessage.includes("2") && !lowerMessage.includes("12")) {
          selectedTime = "09:30"
        } else if (lowerMessage.includes("3") && !lowerMessage.includes("13")) {
          selectedTime = "10:00"
        } else if (lowerMessage.includes("4") && !lowerMessage.includes("14")) {
          selectedTime = "10:30"
        } else if (lowerMessage.includes("5") && !lowerMessage.includes("15")) {
          selectedTime = "11:00"
        } else if (lowerMessage.includes("6") && !lowerMessage.includes("16")) {
          selectedTime = "11:30"
        } else if (lowerMessage.includes("7") && !lowerMessage.includes("17")) {
          selectedTime = "14:00"
        } else if (lowerMessage.includes("8") && !lowerMessage.includes("18")) {
          selectedTime = "14:30"
        } else if (lowerMessage.includes("9") && !lowerMessage.includes("19")) {
          selectedTime = "15:00"
        } else if (lowerMessage.includes("10")) {
          selectedTime = "15:30"
        } else if (lowerMessage.includes("11")) {
          selectedTime = "16:00"
        } else if (lowerMessage.includes("12")) {
          selectedTime = "16:30"
        } else if (lowerMessage.includes("13")) {
          selectedTime = "17:00"
        } else if (lowerMessage.includes("14")) {
          selectedTime = "17:30"
        } else {
          // Try to extract time directly from message
          const timeMatch = message.match(/(\d{1,2}):(\d{2})/)
          if (timeMatch) {
            const hour = timeMatch[1].padStart(2, "0")
            const minute = timeMatch[2]
            selectedTime = `${hour}:${minute}`
          } else {
            selectedTime = "10:00" // Default
          }
        }

        // Validate business hours
        if (!isBusinessHours(selectedTime)) {
          return NextResponse.json({
            success: true,
            message: getBusinessHoursMessage(lang),
            nextStep: "time_selection",
            bookingData,
          })
        }

        // Check availability in database
        const isAvailable = await checkSlotAvailability(bookingData.date!, selectedTime)

        if (!isAvailable) {
          const occupiedMessages = {
            it: `‚ùå **ORARIO GI√Ä OCCUPATO**

L'orario **${selectedTime}** del **${bookingData.date}** √® gi√† prenotato da un altro cliente.

**üîÑ SCEGLI UN ALTRO ORARIO:**

Per favore seleziona un orario diverso dalla lista precedente.

**Quale altro orario preferisci?**`,

            en: `‚ùå **TIME SLOT OCCUPIED**

The time **${selectedTime}** on **${bookingData.date}** is already booked by another client.

**üîÑ CHOOSE ANOTHER TIME:**

Please select a different time from the previous list.

**Which other time do you prefer?**`,
          }

          return NextResponse.json({
            success: true,
            message: occupiedMessages[lang],
            nextStep: "time_selection",
            bookingData,
          })
        }

        const contactMessages = {
          it: `üïê **Orario confermato: ${selectedTime}** ‚úÖ

üìã **INFORMAZIONI DI CONTATTO**

Per completare la prenotazione, ho bisogno dei tuoi dati:

**üìù Inserisci le seguenti informazioni (una per riga):**

1Ô∏è‚É£ **Nome e Cognome**
2Ô∏è‚É£ **Email** 
3Ô∏è‚É£ **Numero di telefono**
4Ô∏è‚É£ **Messaggio opzionale** (descrivi le tue esigenze)

**Esempio:**
Mario Rossi
mario.rossi@email.com  
+39 333 1234567
Vorrei automatizzare il customer service

**Scrivi tutti i dati:**`,

          en: `üïê **Time confirmed: ${selectedTime}** ‚úÖ

üìã **CONTACT INFORMATION**

To complete the booking, I need your details:

**üìù Enter the following information (one per line):**

1Ô∏è‚É£ **Full Name**
2Ô∏è‚É£ **Email**
3Ô∏è‚É£ **Phone Number** 
4Ô∏è‚É£ **Optional Message** (describe your needs)

**Example:**
Mario Rossi
mario.rossi@email.com
+39 333 1234567
I want to automate customer service

**Write all details:**`,
        }

        return NextResponse.json({
          success: true,
          message: contactMessages[lang],
          nextStep: "contact_info",
          bookingData: { ...bookingData, time: selectedTime },
        })
      }

      case "contact_info": {
        // Parse contact information
        const lines = message.split("\n").filter((line) => line.trim().length > 0)

        // Extract information from the message
        const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/
        const phoneRegex = /[+]?[0-9\s\-()]{8,}/

        const email = message.match(emailRegex)?.[0] || ""
        const phone = message.match(phoneRegex)?.[0] || ""

        // Extract name (assume first line is name)
        const name = lines[0] || ""

        // Extract message (everything after phone/email)
        const userMessage = lines.slice(3).join(" ") || ""

        if (!name || !email || !phone) {
          const retryMessages = {
            it: `‚ùå **Informazioni incomplete**

Per favore fornisci tutti i dati richiesti:

**üìù Formato richiesto (una per riga):**
Nome e Cognome
email@esempio.com
+39 333 1234567
Messaggio opzionale

**Riprova con tutti i dati:**`,

            en: `‚ùå **Incomplete information**

Please provide all required details:

**üìù Required format (one per line):**
Full Name
email@example.com
+39 333 1234567
Optional message

**Try again with all details:**`,
          }

          return NextResponse.json({
            success: true,
            message: retryMessages[lang],
            nextStep: "contact_info",
            bookingData,
          })
        }

        const updatedBookingData = {
          ...bookingData,
          name: name.trim(),
          email: email.trim(),
          phone: phone.trim(),
          message: userMessage.trim(),
        }

        const confirmationMessages = {
          it: `‚úÖ **RIEPILOGO PRENOTAZIONE**

üìã **Dettagli della tua consulenza:**

üéØ **Servizio:** ${bookingData.service}
üìÖ **Data:** ${bookingData.date}
üïê **Orario:** ${bookingData.time}
üë§ **Nome:** ${updatedBookingData.name}
üìß **Email:** ${updatedBookingData.email}
üì± **Telefono:** ${updatedBookingData.phone}
${updatedBookingData.message ? `üí¨ **Messaggio:** ${updatedBookingData.message}` : ""}

**üîÑ CONFERMA PRENOTAZIONE**

Tutto corretto? 

‚úÖ **Scrivi "CONFERMA"** per completare la prenotazione
‚ùå **Scrivi "MODIFICA"** per cambiare qualcosa`,

          en: `‚úÖ **BOOKING SUMMARY**

üìã **Your consultation details:**

üéØ **Service:** ${bookingData.service}
üìÖ **Date:** ${bookingData.date}
üïê **Time:** ${bookingData.time}
üë§ **Name:** ${updatedBookingData.name}
üìß **Email:** ${updatedBookingData.email}
üì± **Phone:** ${updatedBookingData.phone}
${updatedBookingData.message ? `üí¨ **Message:** ${updatedBookingData.message}` : ""}

**üîÑ BOOKING CONFIRMATION**

Everything correct?

‚úÖ **Write "CONFIRM"** to complete booking
‚ùå **Write "MODIFY"** to change something`,
        }

        return NextResponse.json({
          success: true,
          message: confirmationMessages[lang],
          nextStep: "confirmation",
          bookingData: updatedBookingData,
        })
      }

      case "confirmation": {
        const lowerMessage = message.toLowerCase()

        if (
          lowerMessage.includes("conferma") ||
          lowerMessage.includes("confirm") ||
          lowerMessage.includes("s√¨") ||
          lowerMessage.includes("yes")
        ) {
          // Final availability check before saving
          const isStillAvailable = await checkSlotAvailability(bookingData.date!, bookingData.time!)

          if (!isStillAvailable) {
            const conflictMessages = {
              it: `‚ùå **CONFLITTO DI PRENOTAZIONE**

Mi dispiace, ma l'orario **${bookingData.time}** del **${bookingData.date}** √® stato appena prenotato da un altro cliente.

**üîÑ RIPROVA CON ALTRO ORARIO:**

Vuoi scegliere un altro orario? Scrivi "ALTRO ORARIO" per vedere gli slot disponibili.`,

              en: `‚ùå **BOOKING CONFLICT**

Sorry, but the time **${bookingData.time}** on **${bookingData.date}** was just booked by another client.

**üîÑ TRY ANOTHER TIME:**

Do you want to choose another time? Write "ANOTHER TIME" to see available slots.`,
            }

            return NextResponse.json({
              success: true,
              message: conflictMessages[lang],
              nextStep: "time_selection",
              bookingData,
            })
          }

          // Save appointment to database
          try {
            const appointmentData = {
              service: bookingData.service,
              date: bookingData.date,
              time: bookingData.time,
              name: bookingData.name,
              email: bookingData.email,
              phone: bookingData.phone,
              message: bookingData.message,
              status: "confirmed",
              priority: false,
            }

            // Call appointments API
            const response = await fetch(
              `${process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000"}/api/appointments`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(appointmentData),
              },
            )

            if (response.ok) {
              const successMessages = {
                it: `üéâ **PRENOTAZIONE CONFERMATA!**

‚úÖ **La tua consulenza √® stata prenotata con successo!**

üìã **Dettagli confermati:**
üéØ **Servizio:** ${bookingData.service}
üìÖ **Data:** ${bookingData.date}
üïê **Orario:** ${bookingData.time}
üë§ **Nome:** ${bookingData.name}

üìß **Email di conferma inviata a:** ${bookingData.email}

**üìû COSA SUCCEDE ORA:**
1. Riceverai un'email di conferma entro 5 minuti
2. Ti contatteremo 24h prima per confermare
3. Riceverai il link per la videocall il giorno stesso

**üöÄ PREPARATI PER LA CONSULENZA:**
- Pensa alle tue esigenze specifiche
- Prepara domande sui nostri servizi
- Porta esempi del tuo business

**Grazie per aver scelto Digital Aura!** üåü

Hai altre domande?`,

                en: `üéâ **BOOKING CONFIRMED!**

‚úÖ **Your consultation has been successfully booked!**

üìã **Confirmed details:**
üéØ **Service:** ${bookingData.service}
üìÖ **Date:** ${bookingData.date}
üïê **Time:** ${bookingData.time}
üë§ **Name:** ${bookingData.name}

üìß **Confirmation email sent to:** ${bookingData.email}

**üìû WHAT HAPPENS NOW:**
1. You'll receive a confirmation email within 5 minutes
2. We'll contact you 24h before to confirm
3. You'll receive the videocall link on the same day

**üöÄ PREPARE FOR THE CONSULTATION:**
- Think about your specific needs
- Prepare questions about our services
- Bring examples of your business

**Thank you for choosing Digital Aura!** üåü

Do you have other questions?`,
              }

              return NextResponse.json({
                success: true,
                message: successMessages[lang],
                completed: true,
                bookingData: appointmentData,
              })
            } else {
              throw new Error("Failed to save appointment")
            }
          } catch (error) {
            console.error("‚ùå Error saving appointment:", error)

            const errorMessages = {
              it: `‚ùå **Errore durante il salvataggio**

Si √® verificato un problema tecnico. 

**üìû PRENOTAZIONE MANUALE:**
Contattaci direttamente per completare la prenotazione:

üìß **Email:** info@digitalaura.it
üì± **Telefono:** +39 02 1234567

**Menziona questi dettagli:**
- Servizio: ${bookingData.service}
- Data: ${bookingData.date}
- Orario: ${bookingData.time}
- Nome: ${bookingData.name}

Ci scusiamo per l'inconveniente!`,

              en: `‚ùå **Error during saving**

A technical problem occurred.

**üìû MANUAL BOOKING:**
Contact us directly to complete the booking:

üìß **Email:** info@digitalaura.it
üì± **Phone:** +39 02 1234567

**Mention these details:**
- Service: ${bookingData.service}
- Date: ${bookingData.date}
- Time: ${bookingData.time}
- Name: ${bookingData.name}

We apologize for the inconvenience!`,
            }

            return NextResponse.json({
              success: true,
              message: errorMessages[lang],
              completed: false,
              bookingData,
            })
          }
        } else if (
          lowerMessage.includes("modifica") ||
          lowerMessage.includes("modify") ||
          lowerMessage.includes("cambia") ||
          lowerMessage.includes("change")
        ) {
          // Restart booking process
          const restartMessages = {
            it: `üìÖ **PRENOTAZIONE CONSULENZA GRATUITA**

Perfetto! Ti aiuto a prenotare una consulenza gratuita direttamente qui.

**üéØ SERVIZI DISPONIBILI:**

1Ô∏è‚É£ **AI Automation** - Automazione processi aziendali
2Ô∏è‚É£ **Chatbot Intelligenti** - Assistenti virtuali 24/7
3Ô∏è‚É£ **Web Development** - Siti web e e-commerce
4Ô∏è‚É£ **AI Marketing** - Campagne automatizzate

**Per quale servizio vuoi prenotare?**
Scrivi il numero (1, 2, 3, 4) o il nome del servizio.`,

            en: `üìÖ **FREE CONSULTATION BOOKING**

Perfect! I'll help you book a free consultation directly here.

**üéØ AVAILABLE SERVICES:**

1Ô∏è‚É£ **AI Automation** - Business process automation
2Ô∏è‚É£ **Intelligent Chatbots** - 24/7 virtual assistants
3Ô∏è‚É£ **Web Development** - Websites and e-commerce
4Ô∏è‚É£ **AI Marketing** - Automated campaigns

**Which service do you want to book for?**
Write the number (1, 2, 3, 4) or service name.`,
          }

          return NextResponse.json({
            success: true,
            message: restartMessages[lang],
            nextStep: "service_selection",
            bookingData: {},
          })
        } else {
          const clarificationMessages = {
            it: `‚ùì **Conferma richiesta**

Per completare la prenotazione:

‚úÖ **Scrivi "CONFERMA"** se i dati sono corretti
‚ùå **Scrivi "MODIFICA"** se vuoi cambiare qualcosa

Cosa vuoi fare?`,

            en: `‚ùì **Confirmation required**

To complete the booking:

‚úÖ **Write "CONFIRM"** if the details are correct
‚ùå **Write "MODIFY"** if you want to change something

What do you want to do?`,
          }

          return NextResponse.json({
            success: true,
            message: clarificationMessages[lang],
            nextStep: "confirmation",
            bookingData,
          })
        }
      }

      default:
        return NextResponse.json({
          success: false,
          message: "Invalid booking step",
        })
    }
  } catch (error) {
    console.error("Booking API Error:", error)

    return NextResponse.json(
      {
        success: false,
        message: "Sorry, there was an error processing your booking request.",
      },
      { status: 500 },
    )
  }
}
